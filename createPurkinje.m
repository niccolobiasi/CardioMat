function [nodes,elem,act_times]=createPurkinje(VoxelMat,transmural,apicobasal,options)
% createPurinje generates a physiological Purkinje network for the
% voxelized geometry VoxelMat based on the method proposed by Ulysses et
% al.
% It requires the transmural and apicobasal coordinates as generated by the
% computeUVC function.
%
% options is used to pass additional parameters:
%- Nterm: number of terminal points in the purkije tree (default=650);
%- Ncon_max: maximum number of candidate connections (default=20);
%- theta_max: maximum bifurcation angle (default= 63 deg);
%- cond_vel: conduction velocity in the purkinje tree (only used to compute
%activation times, default=340 cm/s);
%- res: resolution (only used to compute activation times, default=0.25);
%- depth: maximum relative transmural depth where the terminal nodes can
%lie (default=0.1);
%- maxHeight: maximum apicobasal coordinate where the terminal nodes can
%lie (default=0.9);
%- pknDiff: kernel size used to create the Purkinje region. It determines how
%far segments of purkinje tree can be from the endocardial surface
%(default=5)
%- plot: if true generates a plot of the Purkinje tree.
%
%[nodes,elem,act_times]=createPurkinje(VoxelMat,transmural,apicobasal,options)
%returns:
%- matrix nodes (size=[2*Nterm,3]) containining the position vector of the
%nodes expressed in voxel numeber(i.e., adimensional)
%- a matrix elem (size=[2*Nterm-1,2]) containing the nodes indices
%composing each element.
%- a vector act_times containing the activation time of each node in ms.

if nargin<4
    options=[];
end

if isfield(options,'depth')
    perc=options.depth;
else
    perc=0.1;
end

if isfield(options,'maxHeight')
    maxHeight=options.maxHeight;
else
    maxHeight=0.9;
end

if isfield(options,'pknDiff')
    pknDiff=options.pknDiff;
else
    pknDiff=5;
end

if isfield(options,'Nterm')
    Nterm=options.Nterm;
else
    Nterm=650;
end

if isfield(options,'Ncon_max')
    Ncon_max=options.Ncon_max;
else
    Ncon_max=20;
end

if isfield(options,'theta_max')
    theta_max=options.theta_max;
else
    theta_max=deg2rad(63);
end

if isfield(options,'cond_vel')
    cond_vel=options.cond_vel;
else
    cond_vel=340;
end

if isfield(options,'res')
    res=options.res;
else
    res=0.25;
end

if isfield(options,'plot')
    doplot=options.plot;
else
    doplot=true;
end

endo=zeros(size(VoxelMat));
endo(transmural==0 & VoxelMat(:))=1;

pknLayer=reshape(transmural<perc & VoxelMat(:),size(VoxelMat));
[FV1,extInd1]=computeSurface(endo,1);


pknLayer_diff=imgaussfilt3(double(pknLayer),pknDiff);

pknLayer_diff=pknLayer_diff>(mean(pknLayer_diff,'all')*0.5);
[FV2,extInd2]=computeSurface(pknLayer_diff,1);
F=griddedInterpolant(double(pknLayer_diff),'nearest','none');
lin_ind=find(VoxelMat(:) & transmural<perc & apicobasal<maxHeight);

Npts=length(lin_ind);

[jj,ii,kk]=ind2sub(size(VoxelMat),lin_ind);
S=[ii jj kk];

ld=0.5*nnz(VoxelMat).^(1/3);

%%
disp('Select His bundle starting point')
[root, ~]=selectPoint(pknLayer_diff,FV2, extInd2, 1);
%%
prox=root;
rnd=randperm(Npts);
i=0;
dist=Inf;
while norm(prox-dist)>ld
    i=i+1;
    dist=S(rnd(i),:);
end
S(rnd(i),:)=[];
Npts=Npts-1;

kterm=1;
i=1;
%%
while kterm < Nterm
    %randomly choose one distal position term respecting the distance
    %criterion
    dthresh=ld/sqrt(kterm);
    distFlag=1;
    counter=1;
    while distFlag
        if counter>=10
            dthresh=0.9*dthresh;
            counter=1;
        end
        rnd=randperm(Npts);
        term=S(rnd(i),:);
        i=i+1;
        dcrit=computeDistance(term,prox,dist);
        if dcrit>dthresh
            distFlag=0;
        end
        counter=counter+1;
    end

    %select the Ncon_max nearest segments in the tree
    if size(prox,1)<=Ncon_max
        Ncon=size(prox,1);
        seg2con=1:Ncon;
    else
        Ncon=Ncon_max;
        [~,ind_sort]=sort(dcrit);
        seg2con=ind_sort(1:Ncon_max);
    end

    %for each candidate segment to split find the best bifurcation point
    cand_xbif=zeros(Ncon,3);
    min_len=zeros(Ncon,1);
    for j=1:length(seg2con)
        %find best bifurcation position Local optimization
        [cand_xbif(j,:), min_len(j)] =...
            localOpt(term,prox(seg2con(j),:),dist(seg2con(j),:),theta_max,F);

    end
    %Global optimization
    if isnan(cand_xbif)
        continue
    end
    [~, ind_min]=min(min_len);
    xbif=cand_xbif(ind_min,:);
    seg2split=seg2con(ind_min);
    tmp_prox=prox(seg2split,:);
    tmp_dist=dist(seg2split,:);
    prox(seg2split,:)=[];
    dist(seg2split,:)=[];
    prox=[prox; tmp_prox; xbif; xbif];
    dist=[dist; xbif; tmp_dist; term];
    kterm=kterm+1;
    S(rnd(i),:)=[];
    Npts=Npts-1;
    i=1;

end


%%
%rewrite in elements form
nodes=[prox;dist];

Nel=length(prox);

elem=(1:2*Nel)';
[nodes, ~, Ic]=unique(nodes,'rows');
elem=elem(Ic);
elem=[elem(1:Nel) elem((1+Nel):2*Nel)];
root_node=find(nodes(:,1)==root(1) & nodes(:,2)==root(2) & nodes(:,3)==root(3));
tmp=nodes(1,:);
nodes(1,:)=nodes(root_node,:);
nodes(root_node,:)=tmp;
tmp=elem;
elem(tmp==root_node)=1;
elem(tmp==1)=root_node;
curr_node=1;
act_times=NaN(length(nodes),1);
act_times(curr_node)=0;
while nnz(isnan(act_times))
    [elem_in, loc]=ismember(elem(:,1),curr_node);
    loc=loc(elem_in);
    nodesToact=elem(elem_in,2);

    pathLen=vecnorm(nodes(nodesToact,:)-nodes(curr_node(loc),:),2,2);
    act_times(nodesToact)=act_times(curr_node(loc))+pathLen;

    curr_node=nodesToact;
end

act_times=act_times*res/cond_vel*100;
if doplot
    figure;
    PlotVoxel(FV1,endo,extInd1,[100 100 100]/255,0.1,1);
    hold on
    for i=1:size(elem,1)
        patch(nodes(elem(i,:),1),nodes(elem(i,:),2),nodes(elem(i,:),3),...
            act_times(elem(i,:)),'EdgeColor','interp','LineWidth',3);
    end
    colorbar;
    colormap('jet');
    scatter3(root(1),root(2),root(3),50,'blue','filled','o');
end

end
%% functions
function dcrit=computeDistance(term,prox,dist)

u=prox-dist;
v=term-dist;
w=term-prox;
normu=vecnorm(u,2,2);
normv=vecnorm(v,2,2);
normw=vecnorm(w,2,2);
d=dot(u,v,2)./normu.^2;

crit_ind=d<=1 & d>=0;
dcrit=nan(size(prox,1),1);
dcrit(crit_ind)=vecnorm(cross(v(crit_ind,:),w(crit_ind,:),2),2,2)./normu(crit_ind);
dcrit(not(crit_ind))=min([normv(not(crit_ind)),normw(not(crit_ind))],[],2);
end



function [xbif, min_len]=localOpt(term,prox,dist,theta_max,F)

x1=prox(1);
y1=prox(2);
z1=prox(3);
x2=dist(1);
y2=dist(2);
z2=dist(3);
x3=term(1);
y3=term(2);
z3=term(3);
Ne=10;
eps=(0:1/Ne:1)';
%local mesh
[grid_eps, grid_eta]=meshgrid(eps,eps);
grid_eps=tril(grid_eps);
grid_eta=tril(flip(grid_eta));
grid_eps=grid_eps(tril(true(size(grid_eps))));
grid_eta=grid_eta(tril(true(size(grid_eta))));
grid_eps(1)=[];
grid_eta(1)=[];
grid_eps(Ne)=[];
grid_eta(Ne)=[];
grid_eps(end)=[];
grid_eta(end)=[];


%linear transformation
psi1=1-grid_eps-grid_eta;
psi2=grid_eps;
psi3=grid_eta;

gridx=psi1*x1+psi2*x2+psi3*x3;
gridy=psi1*y1+psi2*y2+psi3*y3;
gridz=psi1*z1+psi2*z2+psi3*z3;

valid=F(gridy,gridx,gridz);
ind=find(valid);
if isempty(ind)
    xbif=NaN(1,3);
    min_len=Inf;
    return
end
gridx=gridx(ind);
gridy=gridy(ind);
gridz=gridz(ind);

valid=F((gridy+y1)/2,(gridx+x1)/2,(gridz+z1)/2);
ind=find(valid==1);
if isempty(ind)
    xbif=NaN(1,3);
    min_len=Inf;
    return
end
gridx=gridx(ind);
gridy=gridy(ind);
gridz=gridz(ind);

valid=F((gridy+y2)/2,(gridx+x2)/2,(gridz+z2)/2);
ind=find(valid==1);
if isempty(ind)
    xbif=NaN(1,3);
    min_len=Inf;
    return
end
gridx=gridx(ind);
gridy=gridy(ind);
gridz=gridz(ind);

valid=F((gridy+y3)/2,(gridx+x3)/2,(gridz+z3)/2);
ind=find(valid==1);
if isempty(ind)
    xbif=NaN(1,3);
    min_len=Inf;
    return
end
gridx=gridx(ind);
gridy=gridy(ind);
gridz=gridz(ind);


v1=[gridx-x1 gridy-y1 gridz-z1];
v2=[gridx-x2 gridy-y2 gridz-z2];
v3=[gridx-x3 gridy-y3 gridz-z3];
normv1=vecnorm(v1,2,2);
normv2=vecnorm(v2,2,2);
normv3=vecnorm(v3,2,2);
len=normv1+normv2+normv3-norm(prox-dist);
angle=real(acos(dot(v2,v3,2)./(normv2.*normv3)));
ind=find(angle<theta_max);
if isempty(ind)
    xbif=NaN(1,3);
    min_len=Inf;
else
    len=len(ind);
    [min_len, min_ind]=min(len);
    min_ind=ind(min_ind);
    xbif=[gridx(min_ind) gridy(min_ind) gridz(min_ind)];
end
end