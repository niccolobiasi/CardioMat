function vox2carp(VoxelMat,filename_out,options)
%vox2carp generates a tetrahedral mesh from a voxelized geometry VoxelMat 
% in CARP format with name filename_out (both pts, elem, and surf file).
% Optional inputs:
%   - KernelSize: window size for gaussian smoothing (default=11)
%   - smoothStd: standard deviation fro gaussian smoothing (default=6)
%   - VoxSize: size of voxels (default=0.25 mm)
%   - maxVol: maximum volume of tetrahedral elements (default=
%   0.5*VoxSize^3)
%   - labels: a vector with length equal to nnz(VoxelMat) defining voxel
%   labels.
%   - fibers: a structure with x, y, and z subfields defining fiber
%   orientation for each voxel. A .lon file is generated. 
%   - fibrosis: a vector with length equal to nnz(VoxelMat) defining 
%   fibrotic voxels. Both a .dat and .regele file are generated.
%
% Tetrahedral mesh is generated by using the iso2mesh toolbox (download
% from: https://github.com/fangq/iso2mesh).
%
% Note: Purkinje network can be exported as line elements but doesn't work properly.
% Propagation from line elements to tetrahedra seems to be not possible in
% openCARP

if nargin<3
    options=[];
end
%kernelSize
if isfield(options,'kernelSize')
    kernelSize=options.kernelSize;
else
    kernelSize=11;
end

%std
if isfield(options,'smoothStd')
    smoothStd=options.smoothStd;
else
    smoothStd=6;
end

if isfield(options,'VoxSize')
    vox_res=options.VoxSize;
else
    vox_res=0.25;
end

%avg_res;
if isfield(options,'maxFaceEdgeSize')
    face_res=options.maxFaceEdgeSize/vox_res;
else
    face_res=1.0;
end

if isfield(options,'maxVol')
    maxVol=options.maxVol/vox_res^3;
else
    maxVol=0.5;
end

if isfield(options,'labels')
    domain=options.labels;
    Dd=1;
else
    Dd=0;
end

if isfield(options,'fibers')
    f=options.fibers;
    Df=1;
else
    Df=0;
end

if isfield(options,'fibrosis')
    fib=options.fibrosis(VoxelMat);
    Dfib=1;
else
    Dfib=0;
end

if isfield(options,'pkj_radius')
    R_pkj=options.pkj_radius/vox_res;
else
    R_pkj=1.5;
end
%%
smoothMat=smooth3(VoxelMat,'gaussian',kernelSize,smoothStd);
[node,elem,face]=v2m(smoothMat,0.5,face_res,maxVol);
elem=elem(:,1:4);
face=face(:,1:3);
nodex=node(:,2);
nodey=node(:,1);
nodez=node(:,3);
if Dd || Df || Dfib
    elemx=mean(nodex(elem),2);
    elemy=mean(nodey(elem),2);
    elemz=mean(nodez(elem),2);
    centroids=[elemx elemy elemz];
    [Ny,Nx,Nz]=size(VoxelMat);
    [gridx, gridy, gridz]=meshgrid(1:Nx,1:Ny,1:Nz);
    gridx=gridx(VoxelMat);
    gridy=gridy(VoxelMat);
    gridz=gridz(VoxelMat);
end
F_defined=0;
if Dd
    F=scatteredInterpolant(gridx,gridy,gridz,domain,'nearest','nearest');
    elem_lab=F(centroids);
    F_defined=1;
else
    elem_lab=zeros(length(elem),1);
end
node(:,1)=nodex;
node(:,2)=nodey;
tmp=face(:,2);
face(:,2)=face(:,3);
face(:,3)=tmp;
%% Purkinje
if isfield(options,'pkj')
    pkn_elem=options.pkj.elem;
    pkn_nodes=options.pkj.nodes;
    term_mask=not(ismember(pkn_elem(:,2),pkn_elem(:,1)));
    term_ind=pkn_elem(term_mask,2);
    term_nodes=pkn_nodes(term_ind,:);
    newElem=pkn_elem+length(node);
    for i=1:length(term_nodes)
        distances=vecnorm(node-term_nodes(i,:),2,2);
        toConnect=find(distances<R_pkj);
        newElem=[newElem; length(node)+term_ind(i)*ones(length(toConnect),1) toConnect];
    end
    fid6=fopen([filename_out '_pkj_root.vtx'],'w+');
    fprintf(fid6,'%u \n',1);
    fprintf(fid6,'extra \n');
    fprintf(fid6,'%u \n',length(node));
    node=[node; pkn_nodes];
    %% refine Pkn mesh
    edge_length=vecnorm(node(newElem(:,1),:)-node(newElem(:,2),:),2,2);
    if isfield(options.pkj,'res')
        desired_res=options.pkj.res/vox_res;
    else
        desired_res=1;
    end
    n_seg=ceil(edge_length/desired_res);
    toDivide=find(n_seg>1);
    for i=1:length(toDivide)
        curr_elem=toDivide(i);
        first_node=node(newElem(curr_elem,1),:);
        last_node=node(newElem(curr_elem,2),:);
        prevElem=newElem(curr_elem,1);
        for j=1:n_seg(curr_elem)-1
            new_node=(1-j/n_seg(curr_elem))*first_node+j/n_seg(curr_elem)*last_node;
            node=[node; new_node];
            newElem=[newElem; prevElem length(node)];
            prevElem=length(node);
        end
        newElem=[newElem; prevElem newElem(curr_elem,2)];
    end
    newElem(toDivide,:)=[];
else 
    newElem=[];
end
%% write to CARP format
node=node*0.25*1000;
str1=[sprintf('%u\n',length(node)),sprintf('%0.5f %0.5f %0.5f\n',node')];
fid1=fopen([filename_out '.pts'],'w+');
fprintf(fid1,str1);
fclose(fid1);

str2=[sprintf('%u\n',length(elem)+length(newElem)),sprintf('Tt %u %u %u %u %u\n',[elem-1 elem_lab]')];
if ~isempty(newElem)
    str2=[str2, sprintf('Ln %u %u %u\n', [newElem-1 7*ones(length(newElem),1)]')];
end
fid2=fopen([filename_out '.elem'],'w+');
fprintf(fid2,str2);
fclose(fid2);

str3=[sprintf('%u\n',length(face)),sprintf('Tr %u %u %u \n',face'-1)];
fid3=fopen([filename_out '.surf'],'w+');
fprintf(fid3,str3);
fclose(fid3);

%% Write fiber file
if Df
    if F_defined==0
        F=scatteredInterpolant(gridx,gridy,gridz,f.x,'nearest','nearest');
        F_defined=1;
    else
        F.Values=f.x;
    end
    fx=F(centroids);
    F.Values=f.y;
    fy=F(centroids);
    F.Values=f.z;
    fz=F(centroids);
    elem_f=[fx fy fz]';
    str4=[sprintf('%u\n',1),sprintf('%0.5f %0.5f %0.5f\n',elem_f)];
    fid4=fopen([filename_out '.lon'],'w+');
    fprintf(fid4,str4);
    fclose(fid4);
end
%% write regele file for fibrosis
if Dfib
    if F_defined==0
        F=scatteredInterpolant(gridx,gridy,gridz,double(fib),'nearest','nearest');
    else
        F.Values=double(fib);
    end
    fib_f=logical(F(centroids));
    writematrix(fib_f,[filename_out '_fib.dat']);
    fib_elem=find(fib_f)-1;
    str5=[sprintf('%u #\n',length(fib_elem)),sprintf('%u\n',fib_elem)];
    fid5=fopen([filename_out '_fib.regele'],'w+');
    fprintf(fid5,str5);
    fclose(fid5);
end

